---
layout: post
title: bit_operation
date: 2024-08-20
tags: [cpp]
author: taot
---

## 位运算使用

在写代码过程中，适当的位运算是一种提高代码质量的有效手段。

### 0 位运算

常用的运算符共 6 种，分别为按位与`&`、按位或`|`、按位异或`^`、按位取反`~`、左移位`<<`、右移位`>>`。

#### 0.1 按位与`&`、按位或`|`、按位异或`^`

按位与`&`、按位或`|`、按位异或`^`,这三者都是两数间的运算。

* 按位与`&`，两个位都是 1 时，结果才为 1，否则为 0
```cpp
​ 1 0 0 1 1 & 1 1 0 0 1 --> ​ 1 0 0 0 1
```

* 按位或`|`，两个位都是 0 时，结果才为 0，否则为 1
```cpp
1 0 0 1 1 | 1 1 0 0 1 --> ​ 1 1 0 1 1
```
用在逻辑判断语句中的 `||` 是逻辑或。

* 按位异或`^`，两个位相同则为 0，不同则为 1
```cpp
1 0 0 1 1 ^ 1 1 0 0 1 -->​ 0 1 0 1 0
```
按位异或运算的逆运算是它本身，也就是说两次按位异或同一个数最后结果不变。


#### 0.2 按位取反`~`

按位取反是针对一个数 进行的计算，即单目运算。`~`把 a 的二进制表示中的 0 和 1 全部取反（0 变为 1，1 变为 0）。有符号整数的符号位在 ~ 运算中同样会取反。

补码：在二进制表示下，正数和 0 的补码为其本身，负数的补码是将其对应正数按位取反后加一。


#### 0.3 左移位`<<`、右移位`>>`
`a << i`表示将 a 的二进制表示向左移动 i 位所得的值。
`a >> i`表示将 a 的二进制表示向右移动 i 位所得的值。

在 C++ 中，右移操作中右侧多余的位将会被舍弃，而左侧较为复杂：对于无符号数，会在左侧补 0；而对于有符号数，则会用最高位的数（其实就是符号位，非负数为 0，负数为 1）补齐。左移操作总是在右侧补 0。
```cpp
int a = 8;
a << 3;
// 移位前：0000 0000 0000 0000 0000 0000 0000 1000
// 移位后：0000 0000 0000 0000 0000 0000 0100 0000

unsigned int b = 8;
b >> 3;
// 移位前：0000 0000 0000 0000 0000 0000 0000 1000
// 移位后：0000 0000 0000 0000 0000 0000 0000 0001

int c = -8;
c >> 3;
// 移位前：1111 1111 1111 1111 1111 1111 1111 1000
// 移位前：1111 1111 1111 1111 1111 1111 1111 1111
```

#### 0.4 复合赋值位运算符

和`+=`,`-=`等运算符类似，位运算也有复合赋值运算符：`&=`, `|=`, `^=`, `<<=`, `>>=`。（取反是单目运算，所以没有。）




### 2 位操作实现乘除法

数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2
```cpp
int a = 2;
a >> 1; ---> 1  // a/2
a << 1; ---> 4  // a*2
```

### 3 位操作交换两数

位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高
```cpp
//普通操作
void swap(int &a, int &b) {
  a = a + b;
  b = a - b;
  a = a - b;
}

//位与操作
void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
}
```
按位与操作解释：
* a ^= b ---> a = (a^b);
* b ^= a ---> b = b(ab) ---> b = (bb)a = a
* a ^= b ---> a = (ab)a = (aa)b = b

### 4 位操作判断奇偶数

只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。
```cpp
if((a & 1)== 0) {
 //偶数
}
if((a & 1)== 1){
  //奇数
}
```

### 5 位操作交换符号

交换符号即将正数变成负数，负数变成正数
```cpp
int reversal(int a) {
  return ~a + 1;
}
```
整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数。

### 6 位操作求绝对值

在某些机器上，效率比`n > 0 ? n : -1 * n`高。
```cpp
int Abs(int n) {
  return (n ^ (n >> 31)) - (n >> 31);
  /* n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1
     若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)
     需要计算 n 和 -1 的补码，然后进行异或运算，
     结果 n 变号并且为 n 的绝对值减 -1，再减去 -1 就是绝对值 */
}
```

### 7 位操作进行高低位交换

给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：
34520 的二进制表示：10000110 11011000

将其高8位与低8位进行交换，得到一个新的二进制数：11011000 10000110，其十进制为 55430

从上面移位操作我们可以知道，只要将无符号数 a>>8 即可得到其高 8 位移到低 8 位，高位补 0；将 a<<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>>8 和 a<<8 进行按位或操作既可求得交换后的结果。
```cpp
unsigned short a = 34520;
a = (a >> 8) | (a << 8);
```

### 8 位操作进行二进制逆序

将无符号数的二进制表示进行逆序，求取逆序后的结果，如
数 34520 的二进制表示：10000110 11011000
逆序后则为：00011011 01100001，它的十进制为 7009

在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。

* 第一步:以每 2 位为一组，组内进行高低位交换

交换前： 10 00 01 10 11 01 10 00
交换后： 01 00 10 01 11 10 01 00
  
* 第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换

交换前： 0100 1001 1110 0100
交换后： 0001 0110 1011 0001

* 第三步：以每 8 位为一组，组内高低位进行交换

交换前： 00010110 10110001
交换后： 01100001 00011011

* 第四步：以每16位为一组，组内高低位进行交换

交换前： 0110000100011011
交换后： 0001101101100001

对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：

原数：  10000110 11011000
奇数位： 10000010 10001000
偶数位： 00000100 01010000

再将奇数位右移一位，偶数位左移一位，此时将两个数按位或即可以达到奇偶位上数据交换的效果：

原数：  10000110 11011000
奇数位右移一位： 0 10000010 1000100
偶数位左移一位：0000100 01010000 0
两数相或得到： 01001001 11100100

上面的方法用位操作可以表示为：

取a的奇数位并用 0 进行填充可以表示为：a & 0xAAAA

取a的偶数为并用 0 进行填充可以表示为：a & 0x5555 

因此，上面的第一步可以表示为：a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1)

同理，可以得到其第二、三和四步为：
a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2)
a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4)
a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8)

因此整个操作为：
```cpp
unsigned short a = 34520;

a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
```

### 9 位操作统计二进制中 1 的个数

统计二进制 1 的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，以 34520 为例，我们计算其 a &= (a-1)的结果：

第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000
第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000
第三次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 
发现，每计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：
```cpp
count = 0  
while(a){  
  a = a & (a - 1);  
  count++;  
} 
```

### 10 找出没有重复的数

一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，找出只出现一次的数。

可以用一个哈希表来存储，每次存储的时候，记录某个数出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。这种方法的时间复杂度为 O(n)，空间复杂度也为 O(n)，不够优雅。

采用位运算来做，可以更加优雅。我们知道，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型数全部依次异或一下，例如这组数据是：1， 2， 3， 4， 5， 1， 2， 3， 4。其中 5 只出现了一次，其他都出现了两次，把他们全部依次异或一下，由于异或支持交换律和结合律，所以:

1^ 2^ 3^ 4^ 5^ 1^ 2^ 3^4 = （1^ 1)^(2 ^ 2)^ (3^ 3)^ (4^ 4)^5= 00005 = 5。

不难得出，只出现一次的数是 5。


### 11 m 的 n 次方

求解 m 的 n 次方，并且不能使用系统自带的 pow 函数，最容易想到的方法是连续让 n 个 m 相乘，代码如下：
```cpp
int pow(int n){
    int tmp = 1;
    for(int i = 1; i <= n; i++) {
        tmp = tmp * m;
    }
    return tmp;
}
```
上面的方法时间复杂度为 O(n)。

考虑 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为: $m^{13} = m^{1000} * m^{100} * m^{1}$

那么可以通过`&1`和`>>1`来逐位读取 1101，为 1 时将该位代表的乘数累乘到最终结果。
```cpp
int pow(int n){
    int sum = 1;
    int tmp = m;
    while(n != 0){
        if(n & 1 == 1){
            sum *= tmp;
        }
        tmp *= tmp;
        n = n >> 1;
    }

    return sum;
}
```
时间复杂度近为 O(logn)。


### 12 找出不大于 N 的最大的 2 的幂指数

传统的做法就是让 1 不断着乘以 2，代码如下：
```cpp
int findN(int N){
    int sum = 1;
   while(true){
        if(sum * 2 > N){
            return sum;
        }
        sum = sum * 2;
   }
}
```
这样做的时间复杂度是 O(logn)，改成位运算，时间复杂度近似 O(1)。

考虑 N = 19，那么转换成二进制就是 00010011。那么我们要找的数就是，把二进制中最左边的 1 保留，后面的 0 全部变为 1。即我们的目标数是 00010000：

* 找到最左边的 1，然后把它右边的所有 0 变成 1
![alt text](image-77.png)
```cpp
int n = 19;
n |= n >> 1;
n |= n >> 2;
n |= n >> 4;
```
过把 n 右移并且做按位或运算。假设最左边的 1 处于二进制位中的第 k 位(从左往右数), 那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1, 然后把 n 与右移后的结果做按位或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;
再次把 n 右移两位，那么得到的结果中第 k+2 和第 k+3 位必定是 1, 然后再次做按位或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复即可

* 把得到的数值加 1，可以得到 00100000 即 00011111 + 1 = 00100000。

* 把得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 >> 1 = 00010000。

最终的代码如下
```cpp
int findN(int n){
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n |= n >> 32;
    return (n + 1) >> 1;
}
```
这种做法的时间复杂度近似 O(1)。

### 13 判断一个数是不是 2 的正整数次幂

`a&(a-1)` 可以用来判断 a 是否是 2 的 n 次幂，即 a 如果是 1、2、4、8、16、32、64、128、256、512、2048、4096... 计算的结果就是 0，否则就是非 0

**原理：**将 2 的幂次方写成二进制形式后，很容易注意到有一个特点：二进制中只有一个 1，并且 1 后面跟了 n 个 0； 因此问题可以转化为判断 1 后面是否跟了 n 个 0 就可以了。

将这个数减去 1 后注意到，仅有的那个 1 会变为 0，而原来的那 n 个 0 会变为 1；因此将原来的数与去减去 1 后的数字进行按位与运算后会发现为零。


### 14 对 2 的非负整数次幂取模

```cpp
int modPowerOfTwo(int x, int mod) { return x & (mod - 1); }
```

### 15 取两个数的最大/最小值

在某些机器上，效率比`a > b ? a : b`高。
```cpp
// 如果 a>=b,(a-b)>>31 为 0，否则为 -1
int max(int a, int b) { return b & ((a - b) >> 31) | a & (~(a - b) >> 31); }
int min(int a, int b) { return a & ((a - b) >> 31) | b & (~(a - b) >> 31); }
```

### 16 判断符号是否相同

```cpp
bool isSameSign(int x, int y) {  // 有 0 的情况例外
  return (x ^ y) >= 0;
}
```

### 17 二进制的状态压缩

二进制状态压缩，是指将一个长度为 m 的 bool 数组用一个 m 位的二进制整数表示并存储的方法。利用下列位运算操作可以实现原 bool 数组中对应下标元素的存取。(xor 等价于 ^)

|操作|运算|
|---|---|
|取出整数 n 在二进制表示下的第 k 位|(n >> k) & 1|
|取出整数n 在二进制表示下的第 0 ~ k - 1 位 (后 k 位)|n & ((1 << k) - 1)|
|对整数 n 在二进制表示下的第 k 位取反|n xor (1 << k)|
|对整数 n 在二进制表示下的第 k 位赋值 1|n | (1 << k)|
|对整数 n 在二进制表示下的第 k 位赋值 0|n & (~(1 << k))|

这种方法运算简便，并且节省了程序运行的时间和空间。当m不太大时，可以直接使用一个整数类型存储。当m较大时，可以使用若干个整数类型（int数组），也可以直接利用 C++ STL 的 bitset 实现。

### 18 获取整型的最大值和最小值

* 获得int型最大值
  ```cpp
  int getMaxInt(){  
        return (1 << 31) - 1;//2147483647， 由于优先级关系，括号不可省略   
  }  
  // 这么写也可以
  int getMaxInt(){  
    return ~(1 << 31);//2147483647   
  }  
  ```
* 获得int型最小值
  ```cpp
  int getMinInt(){  
    return 1 << 31;//-2147483648   
  }  
  ```
* 获得long类型的最大值
  ```cpp
  long getMaxLong(){  
    return ((unsigned long) - 1) >> 1;//2147483647   
  }  
  ```

### 19 对2的n次方取余
```cpp
int quyu(int m, int n){//n为2的次方   
    return m & (n - 1);  
}  
```

### 20 求两个整数的平均值

```cpp
int getAverage(int x, int y){  
        return (x + y) >> 1;   
}   // 这种写法可能会有溢出的问题

// 为了避免溢出，可以这么写
int getAverage(int x, int y){  
        return ((x ^ y) >> 1) + (x & y);   
     /*(x^y) >> 1得到x，y其中一个为1的位并除以2， 
       x&y得到x，y都为1的部分，加一起就是平均数了*/  
}
```

### 21 计算`n+1`, `n-1`, 取相反数

```cpp
// n+1
-~n

// n-1
~-n

// 取相反数
~n + 1;
// 也可以这么写
(n ^ -1) + 1;
```

### 22 sign 函数，参数为 n，当 n>0 时候返回 1，n<0 时返回 -1，n=0 时返回 0
```cpp
return !!n - (((unsigned)n >> 31) << 1); 
```


### 23 gcc内建函数

GCC 中还有一些用于位运算的内建函数:

* `int __builtin_ffs(int x)`：返回 x 的二进制末尾最后一个 1 的位置，位置的编号从 1 开始（最低位编号为 1）。当 x 为 
 0 时返回 0。

* `int __builtin_clz(unsigned int x)`：返回 x 的二进制的前导 0 的个数。当 x 为 0 时，结果未定义。

* `int __builtin_ctz(unsigned int x)`：返回 x 的二进制末尾连续 0 的个数。当 x 为 0 时，结果未定义。

* `int __builtin_clrsb(int x)`：当 x 的符号位为 0 时返回 x 的二进制的前导 0 的个数减一，否则返回 x 的二进制的前导 1 的个数减一。

* `int __builtin_popcount(unsigned int x)`：返回 x 的二进制中 1 的个数。

* `int __builtin_parity(unsigned int x)`：判断 x 的二进制中 1 的个数的奇偶性。

这些函数都可以在函数名末尾添加 l 或 ll （如 `__builtin_popcountll` ）来使参数类型变为 ( unsigned ) long 或 ( unsigned ) long long （返回值仍然是 int 类型）。

由于这些函数是内建函数，经过了编译器的高度优化，运行速度十分快（有些甚至只需要一条指令）。

